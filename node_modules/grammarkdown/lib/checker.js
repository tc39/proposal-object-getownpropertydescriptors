/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var crypto_1 = require("crypto");
var core_1 = require("./core");
var diagnostics_1 = require("./diagnostics");
var tokens_1 = require("./tokens");
var symbols_1 = require("./symbols");
var stringwriter_1 = require("./stringwriter");
var nodes_1 = require("./nodes");
var Checker = (function () {
    function Checker(bindings, diagnostics) {
        this.checkedFileSet = new core_1.Dict();
        this.bindings = bindings;
        this.diagnostics = diagnostics;
    }
    Object.defineProperty(Checker.prototype, "resolver", {
        get: function () {
            if (!this.innerResolver) {
                this.innerResolver = this.createResolver(this.bindings);
            }
            return this.innerResolver;
        },
        enumerable: true,
        configurable: true
    });
    Checker.prototype.checkSourceFile = function (sourceFile) {
        if (!core_1.Dict.has(this.checkedFileSet, sourceFile.filename)) {
            core_1.Dict.set(this.checkedFileSet, sourceFile.filename, true);
            this.sourceFile = sourceFile;
            this.diagnostics.setSourceFile(this.sourceFile);
            for (var _i = 0, _a = sourceFile.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.checkSourceElement(element);
            }
        }
    };
    Checker.prototype.createResolver = function (bindings) {
        return new Resolver(bindings);
    };
    Checker.prototype.checkSourceElement = function (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Production:
                this.checkProduction(node);
                break;
            case tokens_1.SyntaxKind.InvalidSourceElement:
                this.reportInvalidSourceElement(node);
                break;
        }
    };
    Checker.prototype.checkProduction = function (node) {
        this.checkGrammarProduction(node);
        this.checkIdentifier(node.name);
        if (node.parameterList) {
            this.checkParameterList(node.parameterList);
        }
        if (node.body) {
            switch (node.body.kind) {
                case tokens_1.SyntaxKind.OneOfList:
                    this.checkOneOfList(node.body);
                    break;
                case tokens_1.SyntaxKind.RightHandSideList:
                    this.checkRightHandSideList(node.body);
                    break;
                case tokens_1.SyntaxKind.RightHandSide:
                    this.checkRightHandSide(node.body);
                    break;
            }
        }
    };
    Checker.prototype.checkGrammarProduction = function (node) {
        var pos = node.name.end;
        if (node.parameterList) {
            pos = node.parameterList.end;
        }
        if (!node.colonToken) {
            return this.reportGrammarError(pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.ColonToken));
        }
        pos += node.colonToken.end;
        if (!node.body) {
            return this.reportGrammarError(pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.OneOfList,
                tokens_1.SyntaxKind.RightHandSide,
            ]));
        }
        switch (node.body.kind) {
            case tokens_1.SyntaxKind.OneOfList:
            case tokens_1.SyntaxKind.RightHandSide:
            case tokens_1.SyntaxKind.RightHandSideList:
                break;
            default:
                return this.reportGrammarError(pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                    tokens_1.SyntaxKind.OneOfList,
                    tokens_1.SyntaxKind.RightHandSide,
                ]));
        }
        return false;
    };
    Checker.prototype.checkParameterList = function (node) {
        this.checkGrammarParameterList(node);
        for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
            var element = _a[_i];
            this.checkParameter(element);
        }
    };
    Checker.prototype.checkGrammarParameterList = function (node) {
        if (!node.openParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBracketToken));
        }
        if (node.openParenToken.kind === tokens_1.SyntaxKind.OpenParenToken) {
            return this.reportGrammarErrorForNode(node.openParenToken, diagnostics_1.Diagnostics.Obsolete_0_, "Support for using parenthesis to enclose production parameter lists is deprecated and may be removed in a future update. Please switch to bracket's ('[', ']') when enclosing production parameter lists.");
        }
        if (!node.elements) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.closeParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBracketToken));
        }
    };
    Checker.prototype.checkParameter = function (node) {
        this.checkIdentifier(node.name);
    };
    Checker.prototype.checkOneOfList = function (node) {
        this.checkGrammarOneOfList(node);
        if (node.terminals) {
            var terminalSet = new core_1.Dict();
            for (var _i = 0, _a = node.terminals; _i < _a.length; _i++) {
                var terminal = _a[_i];
                var text = terminal.text;
                if (core_1.Dict.has(terminalSet, text)) {
                    this.diagnostics.reportNode(terminal, diagnostics_1.Diagnostics.Duplicate_terminal_0_, text);
                }
                else {
                    core_1.Dict.set(terminalSet, text, true);
                    this.checkTerminal(terminal);
                }
            }
        }
    };
    Checker.prototype.checkGrammarOneOfList = function (node) {
        if (!node.oneKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OneKeyword));
        }
        if (!node.ofKeyword) {
            return this.reportGrammarError(node.oneKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OfKeyword));
        }
        if (!node.terminals) {
            return this.reportGrammarError(node.ofKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Terminal));
        }
        if (node.openIndentToken && !node.closeIndentToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.DedentToken));
        }
        return false;
    };
    Checker.prototype.checkRightHandSideList = function (node) {
        this.checkGrammarRightHandSideList(node);
        if (node.elements) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.checkRightHandSide(element);
            }
        }
    };
    Checker.prototype.checkGrammarRightHandSideList = function (node) {
        if (!node.openIndentToken) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.IndentToken));
        }
        if (!node.elements || node.elements.length === 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken
            ]));
        }
        if (!node.closeIndentToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.DedentToken));
        }
        return false;
    };
    Checker.prototype.checkRightHandSide = function (node) {
        this.checkSymbolSpan(node.head);
        if (node.reference) {
            this.checkLinkReference(node.reference);
        }
    };
    Checker.prototype.checkLinkReference = function (node) {
        this.checkGrammarLinkReference(node);
    };
    Checker.prototype.checkGrammarLinkReference = function (node) {
        if (!node.text) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, "string");
        }
        return false;
    };
    Checker.prototype.checkSymbolSpan = function (node) {
        this.checkGrammarSymbolSpan(node);
        this.checkSymbolSpanOrHigher(node.symbol);
        if (node.next) {
            this.checkSymbolSpanRest(node.next);
        }
    };
    Checker.prototype.checkGrammarSymbolSpan = function (node) {
        if (!node.symbol) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken,
                tokens_1.SyntaxKind.Prose
            ]));
        }
        if (node.next) {
            if (node.symbol.kind === tokens_1.SyntaxKind.Prose) {
                return this.reportGrammarError(node.symbol.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LineTerminatorToken));
            }
        }
        return false;
    };
    Checker.prototype.checkSymbolSpanOrHigher = function (node) {
        if (node.kind === tokens_1.SyntaxKind.Prose) {
            this.checkProse(node);
            return;
        }
        this.checkSymbolOrHigher(node);
    };
    Checker.prototype.checkProse = function (node) {
        if (typeof node.text !== "string") {
            this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
    };
    Checker.prototype.checkSymbolSpanRest = function (node) {
        this.checkGrammarSymbolSpanRest(node);
        this.checkSymbolOrHigher(node.symbol);
        if (node.next) {
            this.checkSymbolSpanRest(node.next);
        }
    };
    Checker.prototype.checkGrammarSymbolSpanRest = function (node) {
        if (!node.symbol) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.OpenBracketToken,
                tokens_1.SyntaxKind.LineTerminatorToken
            ]));
        }
        if (node.symbol.kind === tokens_1.SyntaxKind.Prose) {
            return this.reportGrammarError(node.symbol.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LineTerminatorToken));
        }
        if (node.next && node.next.kind === tokens_1.SyntaxKind.Prose) {
            return this.reportGrammarError(node.next.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LineTerminatorToken));
        }
        return false;
    };
    Checker.prototype.checkSymbolOrHigher = function (node) {
        if (isAssertion(node)) {
            this.checkAssertion(node);
            return;
        }
        this.checkButNotSymbolOrHigher(node);
    };
    Checker.prototype.checkAssertion = function (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.checkEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.checkLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.checkLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.checkNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ParameterValueAssertion:
                this.checkParameterValueAssertion(node);
                break;
            case tokens_1.SyntaxKind.InvalidAssertion:
                this.reportInvalidAssertion(node);
                break;
        }
    };
    Checker.prototype.checkGrammarAssertionHead = function (node) {
        if (!node.openBracketToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBracketToken));
        }
        return false;
    };
    Checker.prototype.checkGrammarAssertionTail = function (node) {
        if (!node.closeBracketToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return false;
    };
    Checker.prototype.checkEmptyAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarEmptyAssertion(node) || this.checkGrammarAssertionTail(node);
    };
    Checker.prototype.checkGrammarEmptyAssertion = function (node) {
        if (!node.emptyKeyword) {
            return this.reportGrammarError(node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.EmptyKeyword, /*quoted*/ true));
        }
    };
    Checker.prototype.checkLookaheadAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarLookaheadAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.lookahead) {
            if (node.lookahead.kind === tokens_1.SyntaxKind.SymbolSet) {
                this.checkSymbolSet(node.lookahead);
                return;
            }
            this.checkSymbolSpanRest(node.lookahead);
        }
    };
    Checker.prototype.checkGrammarLookaheadAssertion = function (node) {
        if (!node.lookaheadKeyword) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LookaheadKeyword, /*quoted*/ true));
        }
        if (!node.operatorToken) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.EqualsEqualsToken,
                tokens_1.SyntaxKind.ExclamationEqualsToken,
                tokens_1.SyntaxKind.LessThanMinusToken,
                tokens_1.SyntaxKind.LessThanExclamationToken
            ]));
        }
        switch (node.operatorToken.kind) {
            case tokens_1.SyntaxKind.EqualsEqualsToken:
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.LessThanExclamationToken:
                break;
            default:
                return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                    tokens_1.SyntaxKind.EqualsEqualsToken,
                    tokens_1.SyntaxKind.ExclamationEqualsToken,
                    tokens_1.SyntaxKind.LessThanMinusToken,
                    tokens_1.SyntaxKind.LessThanExclamationToken
                ]));
        }
        if (!node.lookahead) {
            switch (node.operatorToken.kind) {
                case tokens_1.SyntaxKind.EqualsEqualsToken:
                case tokens_1.SyntaxKind.ExclamationEqualsToken:
                    return this.reportGrammarError(node.operatorToken.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Terminal));
                case tokens_1.SyntaxKind.LessThanMinusToken:
                case tokens_1.SyntaxKind.LessThanExclamationToken:
                    return this.reportGrammarError(node.operatorToken.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBraceToken));
            }
        }
        switch (node.operatorToken.kind) {
            case tokens_1.SyntaxKind.EqualsEqualsToken:
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
                if (node.lookahead.kind !== tokens_1.SyntaxKind.SymbolSpan) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                        tokens_1.SyntaxKind.Terminal,
                        tokens_1.SyntaxKind.Identifier,
                        tokens_1.SyntaxKind.UnicodeCharacterLiteral
                    ]));
                }
                break;
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.LessThanExclamationToken:
                if (node.lookahead.kind !== tokens_1.SyntaxKind.SymbolSet) {
                    return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBraceToken));
                }
                break;
        }
        return false;
    };
    Checker.prototype.checkSymbolSet = function (node) {
        this.checkGrammarSymbolSet(node);
        if (node.elements) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.checkSymbolSpanRest(element);
            }
        }
    };
    Checker.prototype.checkGrammarSymbolSet = function (node) {
        if (!node.openBraceToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBraceToken));
        }
        if (!node.elements) {
            return this.reportGrammarError(node.openBraceToken.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        if (!node.closeBraceToken) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBraceToken));
        }
        return false;
    };
    Checker.prototype.checkLexicalGoalAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarLexicalGoalAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.symbol) {
            this.checkIdentifier(node.symbol);
        }
    };
    Checker.prototype.checkGrammarLexicalGoalAssertion = function (node) {
        if (!node.lexicalKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.LexicalKeyword));
        }
        if (!node.goalKeyword) {
            return this.reportGrammarError(node.lexicalKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.GoalKeyword));
        }
        if (!node.symbol) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        return false;
    };
    Checker.prototype.checkNoSymbolHereAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarNoSymbolHereAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.symbols) {
            for (var _i = 0, _a = node.symbols; _i < _a.length; _i++) {
                var symbol = _a[_i];
                this.checkPrimarySymbol(symbol);
            }
        }
    };
    Checker.prototype.checkGrammarNoSymbolHereAssertion = function (node) {
        if (!node.noKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.NoKeyword));
        }
        if (!node.symbols || node.symbols.length <= 0) {
            return this.reportGrammarError(node.noKeyword.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        if (!node.hereKeyword) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.HereKeyword));
        }
        return false;
    };
    Checker.prototype.checkParameterValueAssertion = function (node) {
        this.checkGrammarAssertionHead(node) || this.checkGrammarParameterValueAssertion(node) || this.checkGrammarAssertionTail(node);
        if (node.name) {
            this.checkIdentifier(node.name);
        }
    };
    Checker.prototype.checkGrammarParameterValueAssertion = function (node) {
        if (node.operatorToken) {
            switch (node.operatorToken.kind) {
                case tokens_1.SyntaxKind.TildeToken:
                case tokens_1.SyntaxKind.PlusToken:
                    break;
                default:
                    return this.reportGrammarErrorForNode(node.operatorToken, diagnostics_1.Diagnostics.Unexpected_token_0_, tokens_1.tokenToString(node.operatorToken.kind));
            }
        }
        return false;
    };
    Checker.prototype.reportInvalidAssertion = function (node) {
        if (this.checkGrammarAssertionHead(node)) {
            return;
        }
        this.reportGrammarError(node.openBracketToken.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
            tokens_1.SyntaxKind.LookaheadKeyword,
            tokens_1.SyntaxKind.LexicalKeyword,
            tokens_1.SyntaxKind.NoKeyword,
            tokens_1.SyntaxKind.TildeToken,
            tokens_1.SyntaxKind.PlusToken
        ]));
    };
    Checker.prototype.checkButNotSymbolOrHigher = function (node) {
        if (node.kind === tokens_1.SyntaxKind.ButNotSymbol) {
            this.checkButNotSymbol(node);
            return;
        }
        this.checkUnarySymbolOrHigher(node);
    };
    Checker.prototype.checkButNotSymbol = function (node) {
        this.checkGrammarButNotSymbol(node);
        this.checkUnarySymbolOrHigher(node.left);
        this.checkUnarySymbolOrHigher(node.right);
    };
    Checker.prototype.checkGrammarButNotSymbol = function (node) {
        if (!node.butKeyword) {
            return this.reportGrammarErrorForNode(node.notKeyword || node.right, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.ButKeyword));
        }
        if (!node.notKeyword) {
            return this.reportGrammarErrorForNode(node.right, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.NotKeyword));
        }
        if (!node.right) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral,
                tokens_1.SyntaxKind.OneKeyword
            ]));
        }
        return false;
    };
    Checker.prototype.checkUnarySymbolOrHigher = function (node) {
        if (node.kind === tokens_1.SyntaxKind.OneOfSymbol) {
            this.checkOneOfSymbol(node);
            return;
        }
        this.checkOptionalSymbolOrHigher(node);
    };
    Checker.prototype.checkOneOfSymbol = function (node) {
        this.checkGrammarOneOfSymbol(node);
        if (node.symbols) {
            for (var _i = 0, _a = node.symbols; _i < _a.length; _i++) {
                var symbol = _a[_i];
                this.checkPrimarySymbol(symbol);
            }
        }
    };
    Checker.prototype.checkGrammarOneOfSymbol = function (node) {
        if (!node.oneKeyword) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OneKeyword));
        }
        if (!node.ofKeyword) {
            return this.reportGrammarError(node.oneKeyword.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OfKeyword));
        }
        if (!node.symbols || node.symbols.length <= 0) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
                tokens_1.SyntaxKind.Identifier,
                tokens_1.SyntaxKind.Terminal,
                tokens_1.SyntaxKind.UnicodeCharacterLiteral
            ]));
        }
        return false;
    };
    Checker.prototype.checkOptionalSymbolOrHigher = function (node) {
        this.checkPrimarySymbol(node, true);
    };
    Checker.prototype.checkPrimarySymbol = function (node, allowOptional) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.Terminal:
                this.checkTerminal(node, allowOptional);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.checkUnicodeCharacterLiteral(node, allowOptional);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.checkUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.checkNonterminal(node, allowOptional);
                break;
            case tokens_1.SyntaxKind.AtToken:
                this.checkPlaceholder(node);
                break;
            default:
                this.reportInvalidSymbol(node);
                break;
        }
    };
    Checker.prototype.checkGrammarOptionalSymbol = function (node, allowOptional) {
        if (node.questionToken) {
            if (!allowOptional || node.questionToken.kind !== tokens_1.SyntaxKind.QuestionToken) {
                return this.reportGrammarErrorForNode(node.questionToken, diagnostics_1.Diagnostics.Unexpected_token_0_, tokens_1.tokenToString(node.questionToken.kind));
            }
        }
        return false;
    };
    Checker.prototype.checkTerminal = function (node, allowOptional) {
        this.checkGrammarOptionalSymbol(node, allowOptional) || this.checkGrammarTerminal(node);
    };
    Checker.prototype.checkGrammarTerminal = function (node) {
        if (typeof node.text !== "string" || node.text.length === 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Terminal));
        }
        return false;
    };
    Checker.prototype.checkGrammarUnicodeCharacterRange = function (node) {
        if (!node.left) {
            return this.reportGrammarErrorForNode(node.throughKeyword || node.right || node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        if (!node.throughKeyword) {
            return this.reportGrammarErrorForNode(node.right || node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.ThroughKeyword));
        }
        if (!node.right) {
            return this.reportGrammarError(node.end, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        return false;
    };
    Checker.prototype.checkUnicodeCharacterRange = function (node) {
        this.checkGrammarUnicodeCharacterRange(node);
        this.checkUnicodeCharacterLiteral(node.left);
        this.checkUnicodeCharacterLiteral(node.right);
    };
    Checker.prototype.checkUnicodeCharacterLiteral = function (node, allowOptional) {
        this.checkGrammarOptionalSymbol(node, allowOptional) || this.checkGrammarUnicodeCharacterLiteral(node);
    };
    Checker.prototype.checkGrammarUnicodeCharacterLiteral = function (node) {
        if (typeof node.text !== "string" || node.text.length === 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.UnicodeCharacterLiteral));
        }
        return false;
    };
    Checker.prototype.checkPlaceholder = function (node) {
    };
    Checker.prototype.checkNonterminal = function (node, allowOptional) {
        this.checkGrammarOptionalSymbol(node, allowOptional);
        this.checkIdentifier(node.name);
        if (node.argumentList) {
            this.checkArgumentList(node.argumentList);
        }
    };
    Checker.prototype.checkArgumentList = function (node) {
        this.checkGrammarArgumentList(node);
        if (node.elements) {
            for (var _i = 0, _a = node.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                this.checkArgument(element);
            }
        }
    };
    Checker.prototype.checkGrammarArgumentList = function (node) {
        if (!node.openParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.OpenBracketToken));
        }
        if (node.openParenToken.kind === tokens_1.SyntaxKind.OpenParenToken) {
            return this.reportGrammarErrorForNode(node.openParenToken, diagnostics_1.Diagnostics.Obsolete_0_, "Support for using parenthesis to enclose an argument list is deprecated and may be removed in a future update. Please switch to bracket's ('[', ']') when enclosing argument lists.");
        }
        if (!node.elements) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        if (!node.closeParenToken) {
            return this.reportGrammarError(node.pos, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.CloseBracketToken));
        }
        return false;
    };
    Checker.prototype.checkArgument = function (node) {
        this.checkGrammarArgument(node);
        this.checkIdentifier(node.name);
    };
    Checker.prototype.checkGrammarArgument = function (node) {
        if (node.questionToken && node.questionToken.kind !== tokens_1.SyntaxKind.QuestionToken) {
            return this.reportGrammarErrorForNode(node.questionToken, diagnostics_1.Diagnostics.Unexpected_token_0_, tokens_1.tokenToString(node.questionToken.kind));
        }
        return false;
    };
    Checker.prototype.reportInvalidSymbol = function (node) {
        this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
            tokens_1.SyntaxKind.Terminal,
            tokens_1.SyntaxKind.Identifier,
            tokens_1.SyntaxKind.OpenBracketToken,
            tokens_1.SyntaxKind.OneKeyword
        ]));
    };
    Checker.prototype.checkIdentifier = function (node) {
        this.checkGrammarIdentifier(node);
        if (node.text) {
            var parent_1 = this.bindings.getParent(node);
            if (parent_1) {
                var symbol;
                switch (parent_1.kind) {
                    case tokens_1.SyntaxKind.Parameter:
                        symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter);
                        var declarationSymbol = this.bindings.getSymbol(parent_1);
                        if (declarationSymbol !== symbol) {
                            this.diagnostics.reportNode(node, diagnostics_1.Diagnostics.Duplicate_identifier_0_, node.text);
                        }
                        return;
                    case tokens_1.SyntaxKind.Production:
                        return;
                    case tokens_1.SyntaxKind.LookaheadAssertion:
                    case tokens_1.SyntaxKind.Nonterminal:
                        symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production, diagnostics_1.Diagnostics.Cannot_find_name_0_);
                        break;
                    case tokens_1.SyntaxKind.Argument:
                        var argument = parent_1;
                        if (argument.questionToken) {
                            symbol = this.resolveSymbol(node, node.text, symbols_1.SymbolKind.Parameter, diagnostics_1.Diagnostics.Cannot_find_name_0_);
                        }
                        else {
                            // get the symbol of the parameter of the target production
                            var nonterminal = this.bindings.getAncestor(parent_1, tokens_1.SyntaxKind.Nonterminal);
                            if (nonterminal && nonterminal.name && nonterminal.name.text) {
                                var productionSymbol = this.resolveSymbol(node, nonterminal.name.text, symbols_1.SymbolKind.Production);
                                if (productionSymbol) {
                                    var production = this.bindings.getDeclarations(productionSymbol)[0];
                                    symbol = this.resolveSymbol(production, node.text, symbols_1.SymbolKind.Parameter, diagnostics_1.Diagnostics.Cannot_find_name_0_);
                                }
                            }
                        }
                        break;
                }
                this.bindings.setSymbol(node, symbol);
            }
        }
    };
    Checker.prototype.checkGrammarIdentifier = function (node) {
        if (typeof node.text === "undefined" && node.text.length <= 0) {
            return this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(tokens_1.SyntaxKind.Identifier));
        }
        return false;
    };
    Checker.prototype.reportInvalidSourceElement = function (node) {
        this.reportGrammarErrorForNode(node, diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([
            tokens_1.SyntaxKind.Production
        ]));
    };
    Checker.prototype.resolveSymbol = function (location, name, meaning, diagnosticMessage) {
        var result = this.bindings.resolveSymbol(location, name, meaning);
        if (!result && diagnosticMessage) {
            this.diagnostics.reportNode(location, diagnosticMessage, name);
        }
        return result;
    };
    Checker.prototype.reportGrammarError = function (pos, diagnosticMessage, arg0, arg1, arg2) {
        this.diagnostics.report(pos, diagnosticMessage, arg0, arg1, arg2);
        return true;
    };
    Checker.prototype.reportGrammarErrorForNode = function (location, diagnosticMessage, arg0, arg1, arg2) {
        this.diagnostics.reportNode(location, diagnosticMessage, arg0, arg1, arg2);
        return true;
    };
    return Checker;
})();
exports.Checker = Checker;
var Resolver = (function () {
    function Resolver(bindings) {
        this.bindings = bindings;
    }
    Resolver.prototype.getProductionLinkId = function (node) {
        var symbol = this.bindings.resolveSymbol(node, node.text, symbols_1.SymbolKind.Production);
        if (symbol) {
            return symbol.name;
        }
        return undefined;
    };
    Resolver.prototype.getRightHandSideLinkId = function (node, includePrefix) {
        var linkId;
        if (node.reference && node.reference.text) {
            linkId = node.reference.text.replace(/[^a-z0-9]+/g, '-');
        }
        else {
            var digest = new RightHandSideDigest();
            linkId = digest.computeHash(node).toLowerCase();
        }
        if (includePrefix) {
            var production = this.bindings.getAncestor(node, tokens_1.SyntaxKind.Production);
            var productionId = this.getProductionLinkId(production.name);
            return productionId + "-" + linkId;
        }
        return linkId;
    };
    return Resolver;
})();
exports.Resolver = Resolver;
var RightHandSideDigest = (function () {
    function RightHandSideDigest() {
    }
    RightHandSideDigest.prototype.computeHash = function (node) {
        this.writer = new stringwriter_1.StringWriter();
        this.writeNode(node.head);
        var hash = crypto_1.createHash("sha1");
        hash.update(this.writer.toString(), "utf8");
        var digest = hash.digest("hex");
        return digest.substr(0, 8);
    };
    RightHandSideDigest.prototype.writeNode = function (node) {
        var _this = this;
        if (!node) {
            return;
        }
        switch (node.kind) {
            case tokens_1.SyntaxKind.Terminal:
                this.writeTerminal(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                this.writeUnicodeCharacterLiteral(node);
                break;
            case tokens_1.SyntaxKind.Prose:
                this.writeProse(node);
                break;
            case tokens_1.SyntaxKind.Nonterminal:
                this.writeNonterminal(node);
                break;
            case tokens_1.SyntaxKind.EmptyAssertion:
                this.writeEmptyAssertion(node);
                break;
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
                this.writeLexicalGoalAssertion(node);
                break;
            case tokens_1.SyntaxKind.LookaheadAssertion:
                this.writeLookaheadAssertion(node);
                break;
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
                this.writeNoSymbolHereAssertion(node);
                break;
            case tokens_1.SyntaxKind.ParameterValueAssertion:
                this.writeParameterValueAssertion(node);
                break;
            case tokens_1.SyntaxKind.UnicodeCharacterRange:
                this.writeUnicodeCharacterRange(node);
                break;
            case tokens_1.SyntaxKind.ButNotSymbol:
                this.writeButNotSymbol(node);
                break;
            case tokens_1.SyntaxKind.OneOfSymbol:
                this.writeOneOfSymbol(node);
                break;
            case tokens_1.SyntaxKind.SymbolSpan:
                this.writeSymbolSpan(node);
                break;
            case tokens_1.SyntaxKind.SymbolSet:
                this.writeSymbolSet(node);
                break;
            case tokens_1.SyntaxKind.ArgumentList:
                this.writeArgumentList(node);
                break;
            case tokens_1.SyntaxKind.Argument:
                this.writeArgument(node);
                break;
            case tokens_1.SyntaxKind.Identifier:
                this.writeIdentifier(node);
                break;
            default:
                if ((node.kind >= tokens_1.SyntaxKind.FirstKeyword && node.kind <= tokens_1.SyntaxKind.LastKeyword) ||
                    (node.kind >= tokens_1.SyntaxKind.FirstPunctuation && node.kind <= tokens_1.SyntaxKind.LastKeyword)) {
                    this.writeToken(node);
                    break;
                }
                else {
                    nodes_1.forEachChild(node, function (child) { return _this.writeNode(child); });
                    break;
                }
        }
    };
    RightHandSideDigest.prototype.write = function (text) {
        if (text) {
            if (this.spaceRequested && this.writer.size > 0) {
                this.spaceRequested = false;
                this.writer.write(" ");
            }
            this.writer.write(text);
        }
    };
    RightHandSideDigest.prototype.writeToken = function (node) {
        this.write(tokens_1.tokenToString(node.kind));
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeTerminal = function (node) {
        this.write("`");
        this.write(node.text);
        this.write("`");
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeUnicodeCharacterLiteral = function (node) {
        this.write("<");
        this.write(node.text);
        this.write(">");
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeProse = function (node) {
        this.write("> ");
        this.write(node.text);
    };
    RightHandSideDigest.prototype.writeNonterminal = function (node) {
        this.writeNode(node.name);
        this.writeNode(node.argumentList);
        this.writeNode(node.questionToken);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeArgumentList = function (node) {
        this.write("[");
        for (var i = 0; i < node.elements.length; ++i) {
            if (i > 0) {
                this.write(", ");
            }
            this.writeNode(node.elements[i]);
        }
        this.write("]");
    };
    RightHandSideDigest.prototype.writeArgument = function (node) {
        this.writeNode(node.questionToken);
        this.writeNode(node.name);
    };
    RightHandSideDigest.prototype.writeEmptyAssertion = function (node) {
        this.write("[empty]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeLexicalGoalAssertion = function (node) {
        this.write("[lexical goal ");
        this.writeNode(node.symbol);
        this.spaceRequested = false;
        this.write("]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeLookaheadAssertion = function (node) {
        this.write("[lookahead ");
        this.writeNode(node.operatorToken);
        this.writeNode(node.lookahead);
        this.spaceRequested = false;
        this.write("]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeNoSymbolHereAssertion = function (node) {
        this.write("[no ");
        for (var i = 0; i < node.symbols.length; ++i) {
            if (i > 0) {
                this.write(" or ");
            }
            this.writeNode(node.symbols[i]);
            this.spaceRequested = false;
        }
        this.write(" here]");
    };
    RightHandSideDigest.prototype.writeParameterValueAssertion = function (node) {
        this.write("[");
        this.writeToken(node.operatorToken);
        this.spaceRequested = false;
        this.writeNode(node.name);
        this.write("]");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeUnicodeCharacterRange = function (node) {
        this.writeNode(node.left);
        this.writeNode(node.throughKeyword);
        this.writeNode(node.right);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeButNotSymbol = function (node) {
        this.writeNode(node.left);
        this.writeNode(node.butKeyword);
        this.writeNode(node.notKeyword);
        this.writeNode(node.right);
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeOneOfSymbol = function (node) {
        this.write("one of ");
        for (var i = 0; i < node.symbols.length; ++i) {
            if (i > 0) {
                this.write(" or ");
            }
            this.writeNode(node.symbols[i]);
            this.spaceRequested = false;
        }
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeSymbolSpan = function (node) {
        this.writeNode(node.symbol);
        this.writeNode(node.next);
    };
    RightHandSideDigest.prototype.writeSymbolSet = function (node) {
        this.write("{ ");
        for (var i = 0; i < node.elements.length; ++i) {
            if (i > 0) {
                this.write(", ");
            }
            this.writeNode(node.elements[i]);
            this.spaceRequested = false;
        }
        this.write(" }");
        this.spaceRequested = true;
    };
    RightHandSideDigest.prototype.writeIdentifier = function (node) {
        this.write(node.text);
    };
    return RightHandSideDigest;
})();
function isAssertion(node) {
    if (node) {
        switch (node.kind) {
            case tokens_1.SyntaxKind.EmptyAssertion:
            case tokens_1.SyntaxKind.LookaheadAssertion:
            case tokens_1.SyntaxKind.LexicalGoalAssertion:
            case tokens_1.SyntaxKind.NoSymbolHereAssertion:
            case tokens_1.SyntaxKind.ParameterValueAssertion:
            case tokens_1.SyntaxKind.InvalidAssertion:
                return true;
        }
    }
    return false;
}

//# sourceMappingURL=checker.js.map
