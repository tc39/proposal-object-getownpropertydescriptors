/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var tokens_1 = require("./tokens");
var diagnostics_1 = require("./diagnostics");
var Scanner = (function () {
    function Scanner(filename, text, diagnostics) {
        this.pos = 0;
        this.len = 0;
        this.startPos = 0;
        this.tokenPos = 0;
        this.token = tokens_1.SyntaxKind.Unknown;
        this.indents = [];
        this.filename = filename;
        this.text = text;
        this.len = text.length;
        this.diagnostics = diagnostics;
    }
    Scanner.prototype.getPos = function () {
        return this.pos;
    };
    Scanner.prototype.getLen = function () {
        return this.len;
    };
    Scanner.prototype.getStartPos = function () {
        return this.startPos;
    };
    Scanner.prototype.getTokenPos = function () {
        return this.tokenPos;
    };
    Scanner.prototype.getToken = function () {
        return this.token;
    };
    Scanner.prototype.getTokenText = function () {
        return this.text.slice(this.tokenPos, this.pos);
    };
    Scanner.prototype.getTokenValue = function () {
        return this.tokenValue;
    };
    Scanner.prototype.getDiagnostics = function () {
        return this.diagnostics;
    };
    Scanner.prototype.scan = function () {
        if (this.hasQueuedToken()) {
            return this.token = this.dequeueToken();
        }
        var token = this.scanToken();
        if (this.hasQueuedToken()) {
            if (token !== -1) {
                this.enqueueToken(token);
            }
            return this.token = this.dequeueToken();
        }
        return this.token = token;
    };
    Scanner.prototype.speculate = function (callback, isLookahead) {
        var savePos = this.pos;
        var saveStartPos = this.startPos;
        var saveTokenPos = this.tokenPos;
        var saveToken = this.token;
        var saveTokenValue = this.tokenValue;
        var saveCopyQueueOnWrite = this.copyQueueOnWrite;
        var saveCopyIndentsOnWrite = this.copyIndentsOnWrite;
        var saveQueue = this.queue;
        var saveIndents = this.indents;
        var saveDiagnostics = this.diagnostics;
        this.diagnostics = diagnostics_1.NullDiagnosticMessages.instance;
        this.copyQueueOnWrite = true;
        this.copyIndentsOnWrite = true;
        var result = callback();
        this.diagnostics = saveDiagnostics;
        if (!result || isLookahead) {
            this.pos = savePos;
            this.startPos = saveStartPos;
            this.tokenPos = saveTokenPos;
            this.token = saveToken;
            this.tokenValue = saveTokenValue;
            this.queue = saveQueue;
            this.indents = saveIndents;
            this.copyQueueOnWrite = saveCopyQueueOnWrite;
            this.copyIndentsOnWrite = saveCopyIndentsOnWrite;
        }
        return result;
    };
    Scanner.prototype.scanToken = function () {
        this.startPos = this.pos;
        this.tokenIsUnterminated = false;
        this.tokenValue = "";
        while (true) {
            this.tokenPos = this.pos;
            if (this.pos >= this.len) {
                return this.token = tokens_1.SyntaxKind.EndOfFileToken;
            }
            var ch = this.text.charCodeAt(this.pos);
            switch (ch) {
                case 10 /* LineFeed */:
                case 13 /* CarriageReturn */:
                    if (ch === 13 /* CarriageReturn */ && this.text.charCodeAt(this.pos + 1) === 10 /* LineFeed */) {
                        this.pos += 2;
                    }
                    else {
                        this.pos++;
                    }
                    this.enqueueToken(tokens_1.SyntaxKind.LineTerminatorToken);
                    this.scanIndent();
                    return -1;
                case 32 /* Space */:
                    if (this.pos === 0) {
                        this.scanIndent();
                        continue;
                    }
                case 9 /* Tab */:
                case 11 /* VerticalTab */:
                case 12 /* FormFeed */:
                    this.pos++;
                    continue;
                case 64 /* At */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.AtToken;
                case 35 /* NumberSign */:
                    return this.pos++, this.tokenValue = this.scanLine(), this.token = tokens_1.SyntaxKind.LinkReference;
                case 34 /* DoubleQuote */:
                case 39 /* SingleQuote */:
                    return this.pos++, this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.StringLiteral), this.token;
                case 96 /* Backtick */:
                    return this.pos++, this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.Terminal), this.token;
                case 124 /* Bar */:
                    return this.pos++, this.tokenValue = this.scanString(ch, this.token = tokens_1.SyntaxKind.Identifier), this.token;
                case 60 /* LessThan */:
                    if (this.text.charCodeAt(this.pos + 1) === 33 /* Exclamation */) {
                        return this.pos += 2, this.token = tokens_1.SyntaxKind.LessThanExclamationToken;
                    }
                    else if (this.text.charCodeAt(this.pos + 1) === 45 /* Minus */) {
                        return this.pos += 2, this.token = tokens_1.SyntaxKind.LessThanMinusToken;
                    }
                    else {
                        return this.pos++, this.tokenValue = this.scanString(62 /* GreaterThan */, this.token = tokens_1.SyntaxKind.UnicodeCharacterLiteral), this.token;
                    }
                case 62 /* GreaterThan */:
                    return this.tokenValue = this.scanProse(), this.token = tokens_1.SyntaxKind.Prose;
                case 47 /* Slash */:
                    if (this.pos + 1 < this.len) {
                        switch (this.text.charCodeAt(this.pos + 1)) {
                            case 47 /* Slash */:
                                this.pos += 2;
                                while (this.pos < this.len) {
                                    if (isLineTerminator(this.text.charCodeAt(this.pos))) {
                                        break;
                                    }
                                    this.pos++;
                                }
                                continue;
                            case 42 /* Asterisk */:
                                this.pos += 2;
                                var commentClosed = false;
                                while (this.pos < this.len) {
                                    ch = this.text.charCodeAt(this.pos);
                                    if (ch === 42 /* Asterisk */ && this.text.charCodeAt(this.pos + 1) === 47 /* Slash */) {
                                        this.pos += 2;
                                        commentClosed = true;
                                        break;
                                    }
                                    this.pos++;
                                }
                                if (!commentClosed) {
                                    this.getDiagnostics().report(this.pos, diagnostics_1.Diagnostics._0_expected, "*/");
                                }
                                continue;
                            case 13 /* CarriageReturn */:
                                if (this.pos + 2 < this.len && this.text.charCodeAt(this.pos + 2) === 10 /* LineFeed */) {
                                    this.pos++;
                                }
                            // fall through
                            case 10 /* LineFeed */:
                            case 8232 /* LineSeparator */:
                            case 8233 /* ParagraphSeparator */:
                                this.pos += 2;
                                continue;
                        }
                    }
                    return this.pos++, this.token = tokens_1.SyntaxKind.Unknown;
                case 40 /* OpenParen */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.OpenParenToken;
                case 41 /* CloseParen */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.CloseParenToken;
                case 91 /* OpenBracket */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.OpenBracketToken;
                case 93 /* CloseBracket */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.CloseBracketToken;
                case 123 /* OpenBrace */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.OpenBraceToken;
                case 125 /* CloseBrace */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.CloseBraceToken;
                case 43 /* Plus */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.PlusToken;
                case 126 /* Tilde */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.TildeToken;
                case 44 /* Comma */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.CommaToken;
                case 58 /* Colon */:
                    if (this.pos + 1 < this.len) {
                        ch = this.text.charCodeAt(this.pos + 1);
                        if (ch === 58 /* Colon */) {
                            if (this.pos + 2 < this.len) {
                                ch = this.text.charCodeAt(this.pos + 2);
                                if (ch === 58 /* Colon */) {
                                    return this.pos += 3, this.token = tokens_1.SyntaxKind.ColonColonColonToken;
                                }
                            }
                            return this.pos += 2, this.token = tokens_1.SyntaxKind.ColonColonToken;
                        }
                    }
                    return this.pos++, this.token = tokens_1.SyntaxKind.ColonToken;
                case 63 /* Question */:
                    return this.pos++, this.token = tokens_1.SyntaxKind.QuestionToken;
                case 61 /* Equals */:
                    if (this.text.charCodeAt(this.pos + 1) === 61 /* Equals */) {
                        return this.pos += 2, this.token = tokens_1.SyntaxKind.EqualsEqualsToken;
                    }
                    return this.pos++, this.token = tokens_1.SyntaxKind.EqualsToken;
                case 33 /* Exclamation */:
                    if (this.text.charCodeAt(this.pos + 1) === 61 /* Equals */) {
                        return this.pos += 2, this.token = tokens_1.SyntaxKind.ExclamationEqualsToken;
                    }
                    return this.pos++, this.token = tokens_1.SyntaxKind.Unknown;
                case 85 /* UpperU */:
                case 117 /* LowerU */:
                    if (this.pos + 5 < this.len
                        && this.text.charCodeAt(this.pos + 1) === 43 /* Plus */
                        && isHexDigit(this.text.charCodeAt(this.pos + 2))
                        && isHexDigit(this.text.charCodeAt(this.pos + 3))
                        && isHexDigit(this.text.charCodeAt(this.pos + 4))
                        && isHexDigit(this.text.charCodeAt(this.pos + 5))) {
                        return this.tokenValue = this.text.substr(this.pos, 6), this.pos += 6, this.token = tokens_1.SyntaxKind.UnicodeCharacterLiteral;
                    }
                // fall-through
                default:
                    if (isIdentifierStart(ch)) {
                        this.pos++;
                        while (this.pos < this.len && isIdentifierPart(ch = this.text.charCodeAt(this.pos))) {
                            this.pos++;
                        }
                        this.tokenValue = this.text.substring(this.tokenPos, this.pos);
                        return this.token = this.getIdentifierToken();
                    }
                    this.getDiagnostics().report(this.pos, diagnostics_1.Diagnostics.Invalid_character);
                    return this.pos++, this.token = tokens_1.SyntaxKind.Unknown;
            }
        }
    };
    Scanner.prototype.scanIndent = function () {
        this.tokenPos = this.pos;
        if (this.pos >= this.len) {
            while (this.indents.length) {
                this.indents.pop();
                this.enqueueToken(tokens_1.SyntaxKind.DedentToken);
            }
            return;
        }
        var ch = this.text.charCodeAt(this.pos);
        while (ch === 32 /* Space */ || ch === 9 /* Tab */) {
            this.pos++;
            ch = this.text.charCodeAt(this.pos);
        }
        var tokenLen = this.pos - this.tokenPos;
        var dedentCount = 0;
        for (var i = 0; i < this.indents.length; i++) {
            tokenLen -= this.indents[i];
            if (tokenLen < 0) {
                dedentCount++;
            }
        }
        if (tokenLen > 0) {
            if (this.copyIndentsOnWrite) {
                this.indents = this.indents.slice(0);
                this.copyIndentsOnWrite = false;
            }
            this.indents.push(tokenLen);
            this.enqueueToken(tokens_1.SyntaxKind.IndentToken);
        }
        else {
            for (var i = 0; i < dedentCount; i++) {
                if (this.copyIndentsOnWrite) {
                    this.indents = this.indents.slice(0);
                    this.copyIndentsOnWrite = false;
                }
                this.indents.pop();
                this.enqueueToken(tokens_1.SyntaxKind.DedentToken);
            }
        }
    };
    Scanner.prototype.scanProse = function () {
        var _this = this;
        this.pos++;
        var result = this.scanLine().trim();
        while (this.pos < this.len) {
            var ch = this.text.charCodeAt(this.pos);
            if (!isLineTerminator(ch)) {
                break;
            }
            var nextLine = this.speculate(function () { return _this.tryScanNextLineOfProse(); }, /*isLookahead*/ false);
            if (nextLine === undefined) {
                break;
            }
            result += nextLine;
        }
        return result;
    };
    Scanner.prototype.tryScanNextLineOfProse = function () {
        var result = this.scanLineTerminator();
        this.skipWhiteSpace();
        if (this.pos < this.len) {
            var ch = this.text.charCodeAt(this.pos);
            if (ch === 62 /* GreaterThan */) {
                this.pos++;
                result += this.scanLine().trim();
                return result;
            }
        }
        return undefined;
    };
    Scanner.prototype.scanLine = function () {
        var start = this.pos;
        while (this.pos < this.len) {
            var ch = this.text.charCodeAt(this.pos);
            if (isLineTerminator(ch)) {
                break;
            }
            this.pos++;
        }
        return this.text.substring(start, this.pos);
    };
    Scanner.prototype.scanLineTerminator = function () {
        var start = this.pos;
        var ch = this.text.charCodeAt(start);
        if (ch === 13 /* CarriageReturn */ && this.text.charCodeAt(start + 1) === 10 /* LineFeed */) {
            this.pos += 2;
        }
        else {
            this.pos++;
        }
        return this.text.substring(start, this.pos);
    };
    Scanner.prototype.skipWhiteSpace = function () {
        while (true) {
            var ch = this.text.charCodeAt(this.pos);
            switch (ch) {
                case 10 /* LineFeed */:
                case 13 /* CarriageReturn */:
                case 32 /* Space */:
                case 9 /* Tab */:
                case 11 /* VerticalTab */:
                case 12 /* FormFeed */:
                    this.pos++;
                    continue;
                default:
                    return;
            }
        }
    };
    Scanner.prototype.scanString = function (quote, kind) {
        var multiLine = false;
        var consumeQuote = true;
        var diagnostic = diagnostics_1.Diagnostics.Unterminated_string_literal;
        var decodeEscapeSequences = true;
        if (kind === tokens_1.SyntaxKind.Identifier) {
            diagnostic = diagnostics_1.Diagnostics.Unterminated_identifier_literal;
        }
        else if (kind === tokens_1.SyntaxKind.Prose) {
            multiLine = true;
            consumeQuote = false;
        }
        else if (kind === tokens_1.SyntaxKind.Terminal) {
            decodeEscapeSequences = false;
        }
        var result = "";
        var start = this.pos;
        while (true) {
            if (this.pos >= this.len) {
                result += this.text.substring(start, this.pos);
                this.tokenIsUnterminated = true;
                this.getDiagnostics().report(this.pos, diagnostic || diagnostics_1.Diagnostics.Unterminated_string_literal);
                break;
            }
            var ch = this.text.charCodeAt(this.pos);
            if (ch === quote) {
                // If this is a terminal that consists solely of a single backtick character (e.g. ```),
                // we capture the backtick.
                if (quote === 96 /* Backtick */ && this.pos === start && this.pos + 1 < this.len) {
                    ch = this.text.charCodeAt(this.pos + 1);
                    if (ch === 96 /* Backtick */) {
                        result = "`";
                        this.pos += 2;
                        break;
                    }
                }
                result += this.text.substring(start, this.pos);
                if (consumeQuote) {
                    this.pos++;
                }
                break;
            }
            else if (decodeEscapeSequences && ch === 92 /* Backslash */) {
                // terminals cannot have escape sequences
                result += this.text.substring(start, this.pos);
                result += this.scanEscapeSequence();
                start = this.pos;
                continue;
            }
            else if (!multiLine && isLineTerminator(ch)) {
                result += this.text.substring(start, this.pos);
                this.tokenIsUnterminated = true;
                this.getDiagnostics().report(this.pos, diagnostic || diagnostics_1.Diagnostics.Unterminated_string_literal);
                break;
            }
            this.pos++;
        }
        return result;
    };
    Scanner.prototype.scanEscapeSequence = function () {
        var start = this.pos;
        this.pos++;
        if (this.pos >= this.len) {
            this.getDiagnostics().report(start, diagnostics_1.Diagnostics.Invalid_escape_sequence);
            return "";
        }
        var ch = this.text.charCodeAt(this.pos++);
        switch (ch) {
            case 48 /* Number0 */:
                return "\0";
            case 98 /* LowerB */:
                return "\b";
            case 116 /* LowerT */:
                return "\t";
            case 110 /* LowerN */:
                return "\n";
            case 118 /* LowerV */:
                return "\v";
            case 102 /* LowerF */:
                return "\f";
            case 114 /* LowerR */:
                return "\r";
            case 39 /* SingleQuote */:
                return "\'";
            case 34 /* DoubleQuote */:
                return "\"";
            case 120 /* LowerX */:
            case 117 /* LowerU */:
                ch = this.scanHexDigits(ch === 120 /* LowerX */ ? 2 : 4, /*mustMatchCount*/ true);
                if (ch >= 0) {
                    return String.fromCharCode(ch);
                }
                else {
                    this.getDiagnostics().report(start, diagnostics_1.Diagnostics.Invalid_escape_sequence);
                    return "";
                }
            // when encountering a LineContinuation (i.e. a backslash and a line terminator sequence),
            // the line terminator is interpreted to be "the empty code unit sequence".
            case 13 /* CarriageReturn */:
                if (this.pos < this.len && this.text.charCodeAt(this.pos) === 10 /* LineFeed */) {
                    this.pos++;
                }
            // fall through
            case 10 /* LineFeed */:
            case 8232 /* LineSeparator */:
            case 8233 /* ParagraphSeparator */:
                return "";
            default:
                return String.fromCharCode(ch);
        }
    };
    Scanner.prototype.scanHexDigits = function (count, mustMatchCount) {
        var digits = 0;
        var value = 0;
        while (digits < count || !mustMatchCount) {
            var ch = this.text.charCodeAt(this.pos);
            if (ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */) {
                value = value * 16 + ch - 48 /* Number0 */;
            }
            else if (ch >= 65 /* UpperA */ && ch <= 70 /* UpperF */) {
                value = value * 16 + ch - 65 /* UpperA */ + 10;
            }
            else if (ch >= 97 /* LowerA */ && ch <= 102 /* LowerF */) {
                value = value * 16 + ch - 97 /* LowerA */ + 10;
            }
            else {
                break;
            }
            this.pos++;
            digits++;
        }
        if (digits < count) {
            value = -1;
        }
        return value;
    };
    Scanner.prototype.scanNumber = function () {
        var start = this.pos;
        while (isDigit(this.text.charCodeAt(this.pos))) {
            this.pos++;
        }
        if (this.text.charCodeAt(this.pos) === 46 /* Dot */) {
            this.pos++;
            while (isDigit(this.text.charCodeAt(this.pos))) {
                this.pos++;
            }
        }
        var end = this.pos;
        if (this.text.charCodeAt(this.pos) === 69 /* UpperE */ || this.text.charCodeAt(this.pos) === 101 /* LowerE */) {
            this.pos++;
            if (this.text.charCodeAt(this.pos) === 43 /* Plus */ || this.text.charCodeAt(this.pos) === 45 /* Minus */) {
                this.pos++;
            }
            if (isDigit(this.text.charCodeAt(this.pos))) {
                this.pos++;
                while (isDigit(this.text.charCodeAt(this.pos))) {
                    this.pos++;
                }
                end = this.pos;
            }
            else {
                this.getDiagnostics().report(start, diagnostics_1.Diagnostics.Digit_expected);
            }
        }
        return +(this.text.substring(start, end));
    };
    Scanner.prototype.getIdentifierToken = function () {
        var len = this.tokenValue.length;
        if (len >= 2 && len <= 9) {
            var ch = this.tokenValue.charCodeAt(0);
            if (ch >= 97 /* LowerA */ && ch <= 116 /* LowerT */) {
                var token = tokens_1.stringToToken(this.tokenValue);
                if (token !== undefined) {
                    return this.token = token;
                }
            }
        }
        return this.token = tokens_1.SyntaxKind.Identifier;
    };
    Scanner.prototype.hasQueuedToken = function () {
        return this.queue && this.queue.length > 0;
    };
    Scanner.prototype.enqueueToken = function (token) {
        if (!this.queue) {
            this.queue = [];
        }
        else if (this.copyQueueOnWrite) {
            this.queue = this.queue.slice(0);
            this.copyQueueOnWrite = false;
        }
        this.queue.push(token);
    };
    Scanner.prototype.dequeueToken = function () {
        if (this.queue && this.queue.length) {
            if (this.copyQueueOnWrite) {
                this.queue = this.queue.slice(0);
                this.copyQueueOnWrite = false;
            }
            return this.queue.shift();
        }
    };
    return Scanner;
})();
exports.Scanner = Scanner;
function isIdentifierStart(ch) {
    return ch >= 65 /* UpperA */ && ch <= 90 /* UpperZ */
        || ch >= 97 /* LowerA */ && ch <= 122 /* LowerZ */
        || ch === 95 /* Underscore */;
}
function isIdentifierPart(ch) {
    return ch >= 65 /* UpperA */ && ch <= 90 /* UpperZ */
        || ch >= 97 /* LowerA */ && ch <= 122 /* LowerZ */
        || ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */
        || ch === 95 /* Underscore */;
}
function isLineTerminator(ch) {
    return ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */;
}
function isDigit(ch) {
    return ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */;
}
function isHexDigit(ch) {
    return ch >= 65 /* UpperA */ && ch <= 70 /* UpperF */
        || ch >= 97 /* LowerA */ && ch <= 102 /* LowerF */
        || ch >= 48 /* Number0 */ && ch <= 57 /* Number9 */;
}

//# sourceMappingURL=scanner.js.map
