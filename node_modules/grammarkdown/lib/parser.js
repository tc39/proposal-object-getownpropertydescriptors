/*!
 *  Copyright 2015 Ron Buckton (rbuckton@chronicles.org)
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
var diagnostics_1 = require("./diagnostics");
var tokens_1 = require("./tokens");
var scanner_1 = require("./scanner");
var nodes_1 = require("./nodes");
var ParsingContext;
(function (ParsingContext) {
    ParsingContext[ParsingContext["SourceElements"] = 0] = "SourceElements";
    ParsingContext[ParsingContext["Parameters"] = 1] = "Parameters";
    ParsingContext[ParsingContext["BracketedParameters"] = 2] = "BracketedParameters";
    ParsingContext[ParsingContext["Arguments"] = 3] = "Arguments";
    ParsingContext[ParsingContext["BracketedArguments"] = 4] = "BracketedArguments";
    ParsingContext[ParsingContext["RightHandSideListIndented"] = 5] = "RightHandSideListIndented";
    ParsingContext[ParsingContext["SymbolSet"] = 6] = "SymbolSet";
    ParsingContext[ParsingContext["OneOfList"] = 7] = "OneOfList";
    ParsingContext[ParsingContext["OneOfListIndented"] = 8] = "OneOfListIndented";
    ParsingContext[ParsingContext["OneOfSymbolList"] = 9] = "OneOfSymbolList";
    ParsingContext[ParsingContext["NoSymbolHere"] = 10] = "NoSymbolHere";
})(ParsingContext || (ParsingContext = {}));
var SkipWhitespace;
(function (SkipWhitespace) {
    SkipWhitespace[SkipWhitespace["None"] = 0] = "None";
    SkipWhitespace[SkipWhitespace["LineTerminator"] = 1] = "LineTerminator";
    SkipWhitespace[SkipWhitespace["Indentation"] = 2] = "Indentation";
    SkipWhitespace[SkipWhitespace["All"] = 3] = "All";
})(SkipWhitespace || (SkipWhitespace = {}));
var Parser = (function () {
    function Parser(diagnostics) {
        this.diagnostics = diagnostics;
    }
    Parser.prototype.parseSourceFile = function (filename, text) {
        this.sourceFile = new nodes_1.SourceFile(filename, text);
        this.diagnostics.setSourceFile(this.sourceFile);
        this.scanner = new scanner_1.Scanner(filename, text, this.diagnostics);
        this.parsingContext = ParsingContext.SourceElements;
        this.nextToken();
        this.sourceFile.elements = this.parseSourceElementList() || [];
        var imports = [];
        for (var _i = 0, _a = this.sourceFile.elements; _i < _a.length; _i++) {
            var element = _a[_i];
            if (element.kind === tokens_1.SyntaxKind.Import) {
                var importNode = element;
                if (importNode.path) {
                    imports.push(importNode.path.text);
                }
            }
        }
        this.sourceFile.imports = imports;
        return this.sourceFile;
    };
    Parser.prototype.nextToken = function () {
        return this.token = this.scanner.scan();
    };
    Parser.prototype.lookahead = function (callback) {
        return this.speculate(callback, /*isLookahead*/ true);
    };
    Parser.prototype.tryParse = function (callback) {
        return this.speculate(callback, /*isLookahead*/ false);
    };
    Parser.prototype.speculate = function (callback, isLookahead) {
        var saveToken = this.token;
        var saveParsingContext = this.parsingContext;
        var saveDiagnostics = this.diagnostics;
        this.diagnostics = diagnostics_1.NullDiagnosticMessages.instance;
        var result = this.scanner.speculate(callback, isLookahead);
        this.diagnostics = saveDiagnostics;
        if (!result || isLookahead) {
            this.token = saveToken;
            this.parsingContext = saveParsingContext;
        }
        return result;
    };
    Parser.prototype.isWhitespace = function (skip) {
        if (skip === void 0) { skip = SkipWhitespace.All; }
        switch (this.token) {
            case tokens_1.SyntaxKind.LineTerminatorToken:
                return !!(skip & SkipWhitespace.LineTerminator);
            case tokens_1.SyntaxKind.IndentToken:
            case tokens_1.SyntaxKind.DedentToken:
                return !!(skip & SkipWhitespace.Indentation);
            default:
                return false;
        }
    };
    Parser.prototype.isEOF = function () {
        return this.token === tokens_1.SyntaxKind.EndOfFileToken;
    };
    Parser.prototype.skipUntil = function (isRecoveryToken) {
        while (!isRecoveryToken(this.token) && !this.isEOF()) {
            this.nextToken();
        }
    };
    Parser.prototype.skipWhitespace = function (skip) {
        if (skip === void 0) { skip = SkipWhitespace.All; }
        while (this.isWhitespace(skip)) {
            this.nextToken();
        }
    };
    Parser.prototype.readTokenValue = function (token) {
        if (this.token === token) {
            var text = this.scanner.getTokenValue();
            this.nextToken();
            return text;
        }
        return undefined;
    };
    Parser.prototype.readTokenText = function (token) {
        if (this.token === token) {
            var text = this.scanner.getTokenText();
            this.nextToken();
            return text;
        }
        return undefined;
    };
    Parser.prototype.finishNode = function (node, fullStart) {
        if (node) {
            node.pos = fullStart;
            node.end = this.scanner.getStartPos();
        }
        return node;
    };
    Parser.prototype.parseToken = function (token) {
        if (this.token === token) {
            var fullStart = this.scanner.getStartPos();
            this.nextToken();
            return this.finishNode(new nodes_1.Node(token), fullStart);
        }
        return undefined;
    };
    Parser.prototype.parseAnyToken = function (predicate) {
        if (predicate(this.token)) {
            var fullStart = this.scanner.getStartPos();
            var node = new nodes_1.Node(this.token);
            this.nextToken();
            return this.finishNode(node, fullStart);
        }
        return undefined;
    };
    Parser.prototype.parseOptional = function (token) {
        if (this.token === token) {
            this.nextToken();
            return true;
        }
        else {
            return false;
        }
    };
    Parser.prototype.parseExpected = function (token) {
        if (this.token === token) {
            this.nextToken();
            return true;
        }
        else {
            this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics._0_expected, tokens_1.tokenToString(token));
            return false;
        }
    };
    Parser.prototype.parseExpectedOrEndOfFile = function (token) {
        if (this.isEOF()) {
            return true;
        }
        return this.parseExpected(token);
    };
    // list parsing
    Parser.prototype.shouldParseElement = function () {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                return this.isStartOfSourceElement();
            case ParsingContext.Parameters:
            case ParsingContext.BracketedParameters:
                return this.isStartOfParameter();
            case ParsingContext.Arguments:
            case ParsingContext.BracketedArguments:
                return this.isStartOfArgument();
            case ParsingContext.RightHandSideListIndented:
                return this.isStartOfRightHandSide();
            case ParsingContext.SymbolSet:
                return this.token === tokens_1.SyntaxKind.Terminal || this.token === tokens_1.SyntaxKind.Identifier || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
                return this.token === tokens_1.SyntaxKind.Terminal || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            case ParsingContext.OneOfSymbolList:
                return this.token === tokens_1.SyntaxKind.Terminal || this.token === tokens_1.SyntaxKind.Identifier || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            case ParsingContext.NoSymbolHere:
                return this.token === tokens_1.SyntaxKind.Terminal || this.token === tokens_1.SyntaxKind.Identifier || this.token === tokens_1.SyntaxKind.UnicodeCharacterLiteral;
            default:
                return false;
        }
    };
    Parser.prototype.shouldSkipWhitespace = function () {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                // whitespace in the SourceElements context has no meaning
                return SkipWhitespace.LineTerminator
                    | SkipWhitespace.Indentation;
            case ParsingContext.Parameters:
            case ParsingContext.BracketedParameters:
            case ParsingContext.Arguments:
            case ParsingContext.BracketedArguments:
            case ParsingContext.SymbolSet:
                // These elements are enclosed in parenthesis or braces, so whitespace has no meaning
                return SkipWhitespace.LineTerminator
                    | SkipWhitespace.Indentation;
            case ParsingContext.RightHandSideListIndented:
                // All whitespace is significant in a RHS list
                return SkipWhitespace.LineTerminator;
            case ParsingContext.OneOfList:
                // All whitespace is significant in a one-of list (non-indented)
                return SkipWhitespace.None;
            case ParsingContext.OneOfListIndented:
                // Only indentation is significatn in a one-of list (indented)
                return SkipWhitespace.LineTerminator;
            case ParsingContext.OneOfSymbolList:
                return SkipWhitespace.None;
            case ParsingContext.NoSymbolHere:
                return SkipWhitespace.None;
            default:
                // assume significant whitespace for new parsing contexts
                return SkipWhitespace.None;
        }
    };
    Parser.prototype.shouldConsumeCloseToken = function () {
        switch (this.parsingContext) {
            case ParsingContext.Parameters:
            case ParsingContext.BracketedParameters:
            case ParsingContext.Arguments:
            case ParsingContext.BracketedArguments:
            case ParsingContext.SymbolSet:
            case ParsingContext.OneOfListIndented:
            case ParsingContext.RightHandSideListIndented:
            case ParsingContext.NoSymbolHere:
                return false;
            default:
                return true;
        }
    };
    Parser.prototype.parseElement = function () {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                return this.parseSourceElement();
            case ParsingContext.Parameters:
            case ParsingContext.BracketedParameters:
                return this.parseParameter();
            case ParsingContext.Arguments:
            case ParsingContext.BracketedArguments:
                return this.parseArgument();
            case ParsingContext.RightHandSideListIndented:
                return this.parseRightHandSide();
            case ParsingContext.SymbolSet:
                return this.parseSymbolSpan();
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
                return this.parseTerminal(/*allowOptional*/ false);
            case ParsingContext.OneOfSymbolList:
            case ParsingContext.NoSymbolHere:
                return this.parsePrimarySymbol(/*allowOptional*/ false);
            default:
                console.error("Unexpected parsing context: " + ParsingContext[this.parsingContext]);
                return undefined;
        }
    };
    Parser.prototype.recover = function () {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                this.skipUntil(isSourceElementsRecoveryToken);
                break;
            case ParsingContext.Parameters:
                this.skipUntil(isParametersRecoveryToken);
                if (this.token === tokens_1.SyntaxKind.LineTerminatorToken) {
                    this.nextToken();
                }
                break;
            case ParsingContext.BracketedParameters:
                this.skipUntil(isBracketedParametersRecoveryToken);
                if (this.token === tokens_1.SyntaxKind.LineTerminatorToken) {
                    this.nextToken();
                }
                break;
            case ParsingContext.Arguments:
                this.skipUntil(isArgumentsRecoveryToken);
                if (this.token === tokens_1.SyntaxKind.LineTerminatorToken) {
                    this.nextToken();
                }
                break;
            case ParsingContext.BracketedArguments:
                this.skipUntil(isBracketedArgumentsRecoveryToken);
                if (this.token === tokens_1.SyntaxKind.LineTerminatorToken) {
                    this.nextToken();
                }
                break;
            case ParsingContext.RightHandSideListIndented:
                this.skipUntil(isRightHandSideListIndentedRecoveryToken);
                break;
            case ParsingContext.SymbolSet:
                this.skipUntil(isSymbolSetRecoveryToken);
                if (this.token === tokens_1.SyntaxKind.LineTerminatorToken) {
                    this.nextToken();
                }
                break;
            case ParsingContext.OneOfList:
                this.skipUntil(isOneOfListRecoveryToken);
                break;
            case ParsingContext.OneOfListIndented:
                this.skipUntil(isOneOfListIndentedRecoveryToken);
                if (this.token === tokens_1.SyntaxKind.LineTerminatorToken) {
                    this.nextToken();
                }
                break;
            case ParsingContext.OneOfSymbolList:
                this.skipUntil(isOneOfSymbolListRecoveryToken);
                break;
            case ParsingContext.NoSymbolHere:
                this.skipUntil(isNoSymbolHereRecoveryToken);
                break;
        }
    };
    Parser.prototype.reportDiagnostics = function () {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics.Production_expected);
                break;
            case ParsingContext.Parameters:
            case ParsingContext.Arguments:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.CommaToken, tokens_1.SyntaxKind.CloseParenToken]));
                break;
            case ParsingContext.BracketedParameters:
            case ParsingContext.BracketedArguments:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.CommaToken, tokens_1.SyntaxKind.CloseBracketToken]));
                break;
            case ParsingContext.SymbolSet:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.CommaToken, tokens_1.SyntaxKind.CloseBraceToken]));
                break;
            case ParsingContext.OneOfList:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.Terminal, tokens_1.SyntaxKind.LineTerminatorToken]));
                break;
            case ParsingContext.OneOfListIndented:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics._0_expected, diagnostics_1.formatList([tokens_1.SyntaxKind.Terminal, tokens_1.SyntaxKind.DedentToken]));
                break;
            case ParsingContext.RightHandSideListIndented:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics.Production_expected);
                break;
        }
    };
    Parser.prototype.hasCloseToken = function () {
        switch (this.parsingContext) {
            case ParsingContext.OneOfSymbolList:
            case ParsingContext.NoSymbolHere:
                return false;
        }
        return true;
    };
    Parser.prototype.isOnCloseToken = function () {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
                return this.token === tokens_1.SyntaxKind.EndOfFileToken;
            case ParsingContext.Parameters:
            case ParsingContext.Arguments:
                return this.token === tokens_1.SyntaxKind.CloseParenToken;
            case ParsingContext.BracketedParameters:
            case ParsingContext.BracketedArguments:
                return this.token === tokens_1.SyntaxKind.CloseBracketToken;
            case ParsingContext.RightHandSideListIndented:
                return this.token === tokens_1.SyntaxKind.DedentToken || this.token === tokens_1.SyntaxKind.EndOfFileToken;
            case ParsingContext.SymbolSet:
                return this.token === tokens_1.SyntaxKind.CloseBraceToken;
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
                return this.token === tokens_1.SyntaxKind.DedentToken || this.token === tokens_1.SyntaxKind.EndOfFileToken;
            case ParsingContext.OneOfSymbolList:
                return false;
            case ParsingContext.NoSymbolHere:
                return this.token === tokens_1.SyntaxKind.HereKeyword;
        }
    };
    Parser.prototype.parseCloseToken = function () {
        if (this.isOnCloseToken()) {
            this.parseToken(this.token);
            return true;
        }
        return false;
    };
    Parser.prototype.hasSeparator = function () {
        switch (this.parsingContext) {
            case ParsingContext.SourceElements:
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
                return false;
            default:
                return true;
        }
    };
    Parser.prototype.isOnSeparator = function () {
        switch (this.parsingContext) {
            case ParsingContext.Parameters:
            case ParsingContext.BracketedParameters:
            case ParsingContext.Arguments:
            case ParsingContext.BracketedArguments:
            case ParsingContext.SymbolSet:
                return this.token === tokens_1.SyntaxKind.CommaToken;
            case ParsingContext.RightHandSideListIndented:
                return this.token === tokens_1.SyntaxKind.LineTerminatorToken;
            case ParsingContext.OneOfSymbolList:
            case ParsingContext.NoSymbolHere:
                return this.token === tokens_1.SyntaxKind.OrKeyword;
            case ParsingContext.SourceElements:
            case ParsingContext.OneOfList:
            case ParsingContext.OneOfListIndented:
                return false;
        }
    };
    Parser.prototype.parseSeparator = function () {
        if (this.isOnSeparator()) {
            this.parseToken(this.token);
            return true;
        }
        return false;
    };
    Parser.prototype.parseList = function (listContext) {
        var saveContext = this.parsingContext;
        this.parsingContext = listContext;
        var hasCloseToken = this.hasCloseToken();
        var hasSeparator = this.hasSeparator();
        var shouldConsumeCloseToken = this.shouldConsumeCloseToken();
        var whitespaceToSkip = this.shouldSkipWhitespace();
        var result;
        while (!this.isEOF()) {
            this.skipWhitespace(whitespaceToSkip);
            var parsed = false;
            if (this.shouldParseElement()) {
                parsed = true;
                if (!result) {
                    result = [];
                }
                var element = this.parseElement();
                if (element) {
                    result.push(element);
                }
            }
            if (hasCloseToken && (shouldConsumeCloseToken ? this.parseCloseToken() : this.isOnCloseToken())) {
                break;
            }
            if (!(hasSeparator ? this.parseSeparator() : parsed)) {
                if (!hasCloseToken) {
                    break;
                }
                else {
                    this.reportDiagnostics();
                    this.recover();
                }
            }
        }
        this.parsingContext = saveContext;
        return result;
    };
    Parser.prototype.canBeIdentifier = function (kind) {
        if (kind === tokens_1.SyntaxKind.Identifier) {
            return true;
        }
        return kind >= tokens_1.SyntaxKind.FirstKeyword && kind <= tokens_1.SyntaxKind.LastKeyword;
    };
    Parser.prototype.parseIdentifier = function () {
        var fullStart = this.scanner.getStartPos();
        var text = this.canBeIdentifier(this.token) && this.readTokenValue(this.token);
        var node = new nodes_1.Identifier(text);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseUnicodeCharacterLiteral = function (allowOptional) {
        var fullStart = this.scanner.getTokenPos();
        var text = this.readTokenText(tokens_1.SyntaxKind.UnicodeCharacterLiteral);
        var questionToken = allowOptional ? this.parseToken(tokens_1.SyntaxKind.QuestionToken) : undefined;
        var node = new nodes_1.UnicodeCharacterLiteral(text, questionToken);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseProse = function () {
        var fullStart = this.scanner.getStartPos();
        var text = this.readTokenValue(tokens_1.SyntaxKind.Prose);
        var node = new nodes_1.Prose(text);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.isStartOfParameter = function () {
        return this.canBeIdentifier(this.token);
    };
    Parser.prototype.parseParameter = function () {
        var fullStart = this.scanner.getStartPos();
        var name = this.parseIdentifier();
        var node = new nodes_1.Parameter(name);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseParameterListTail = function (openToken, parsingContext, closeTokenKind) {
        var elements = this.parseList(parsingContext);
        var closeToken = this.parseToken(closeTokenKind);
        var node = new nodes_1.ParameterList(openToken, elements, closeToken);
        return this.finishNode(node, openToken.pos);
    };
    Parser.prototype.tryParseParameterList = function () {
        var openToken = this.parseToken(tokens_1.SyntaxKind.OpenParenToken);
        if (openToken) {
            return this.parseParameterListTail(openToken, ParsingContext.Parameters, tokens_1.SyntaxKind.CloseParenToken);
        }
        else {
            openToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketToken);
            if (openToken) {
                return this.parseParameterListTail(openToken, ParsingContext.BracketedParameters, tokens_1.SyntaxKind.CloseBracketToken);
            }
        }
        return undefined;
    };
    Parser.prototype.parseOneOfList = function () {
        var oneKeyword = this.parseToken(tokens_1.SyntaxKind.OneKeyword);
        var ofKeyword = this.parseToken(tokens_1.SyntaxKind.OfKeyword);
        this.parseOptional(tokens_1.SyntaxKind.LineTerminatorToken);
        var openIndentToken = this.parseToken(tokens_1.SyntaxKind.IndentToken);
        var terminals = this.parseList(openIndentToken ? ParsingContext.OneOfListIndented : ParsingContext.OneOfList);
        var closeIndentToken = this.parseToken(tokens_1.SyntaxKind.DedentToken);
        var node = new nodes_1.OneOfList(oneKeyword, ofKeyword, openIndentToken, terminals, closeIndentToken);
        return this.finishNode(node, oneKeyword.pos);
    };
    Parser.prototype.parseSymbolSetTail = function (openBraceToken) {
        var terminals = this.parseList(ParsingContext.SymbolSet);
        var closeBraceToken = this.parseToken(tokens_1.SyntaxKind.CloseBraceToken);
        var node = new nodes_1.SymbolSet(openBraceToken, terminals, closeBraceToken);
        return this.finishNode(node, openBraceToken.pos);
    };
    Parser.prototype.parseSymbolSpanRestOrSymbolSet = function () {
        var openBraceToken = this.parseToken(tokens_1.SyntaxKind.OpenBraceToken);
        if (openBraceToken) {
            return this.parseSymbolSetTail(openBraceToken);
        }
        else {
            return this.parseSymbolSpanRest();
        }
    };
    Parser.prototype.parseEmptyAssertionTail = function (openBracketToken) {
        var emptyKeyword = this.parseToken(tokens_1.SyntaxKind.EmptyKeyword);
        var closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        var node = new nodes_1.EmptyAssertion(openBracketToken, emptyKeyword, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    };
    Parser.prototype.parseAnyLookaheadOperator = function () {
        switch (this.token) {
            case tokens_1.SyntaxKind.EqualsEqualsToken:
            case tokens_1.SyntaxKind.ExclamationEqualsToken:
            case tokens_1.SyntaxKind.LessThanMinusToken:
            case tokens_1.SyntaxKind.LessThanExclamationToken:
                return this.parseToken(this.token);
            default:
                return undefined;
        }
    };
    Parser.prototype.parseLookaheadAssertionTail = function (openBracketToken) {
        var lookaheadKeyword = this.parseToken(tokens_1.SyntaxKind.LookaheadKeyword);
        var operatorToken = this.parseAnyLookaheadOperator();
        var lookahead = this.parseSymbolSpanRestOrSymbolSet();
        var closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        var node = new nodes_1.LookaheadAssertion(openBracketToken, lookaheadKeyword, operatorToken, lookahead, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    };
    Parser.prototype.parseNoSymbolHereAssertionTail = function (openBracketToken) {
        var noKeyword = this.parseToken(tokens_1.SyntaxKind.NoKeyword);
        var symbols = this.parseList(ParsingContext.NoSymbolHere);
        var hereKeyword = this.parseToken(tokens_1.SyntaxKind.HereKeyword);
        var closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        var node = new nodes_1.NoSymbolHereAssertion(openBracketToken, noKeyword, symbols, hereKeyword, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    };
    Parser.prototype.parseLexicalGoalAssertionTail = function (openBracketToken) {
        var lexicalKeyword = this.parseToken(tokens_1.SyntaxKind.LexicalKeyword);
        var goalKeyword = this.parseToken(tokens_1.SyntaxKind.GoalKeyword);
        var symbol = this.parseIdentifier();
        var closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        var node = new nodes_1.LexicalGoalAssertion(openBracketToken, lexicalKeyword, goalKeyword, symbol, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    };
    Parser.prototype.parseAnyParameterValueOperator = function () {
        switch (this.token) {
            case tokens_1.SyntaxKind.PlusToken:
            case tokens_1.SyntaxKind.TildeToken:
                return this.parseToken(this.token);
            default:
                return undefined;
        }
    };
    Parser.prototype.parseParameterValueAssertionTail = function (openBracketToken) {
        var operatorToken = this.parseAnyParameterValueOperator();
        var name = this.parseIdentifier();
        var closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        var node = new nodes_1.ParameterValueAssertion(openBracketToken, operatorToken, name, closeBracketToken);
        return this.finishNode(node, openBracketToken.pos);
    };
    Parser.prototype.parseInvalidAssertionTail = function (openBracketToken) {
        var fullStart = this.scanner.getStartPos();
        this.skipUntil(isInvalidConstraintTailRecoveryToken);
        var closeBracketToken = this.parseToken(tokens_1.SyntaxKind.CloseBracketToken);
        var node = new nodes_1.Assertion(tokens_1.SyntaxKind.InvalidAssertion, openBracketToken, closeBracketToken);
        this.finishNode(node, fullStart);
        return node;
    };
    Parser.prototype.parseAssertion = function () {
        var openBracketToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketToken);
        switch (this.token) {
            case tokens_1.SyntaxKind.EmptyKeyword:
                return this.parseEmptyAssertionTail(openBracketToken);
            case tokens_1.SyntaxKind.LookaheadKeyword:
                return this.parseLookaheadAssertionTail(openBracketToken);
            case tokens_1.SyntaxKind.NoKeyword:
                return this.parseNoSymbolHereAssertionTail(openBracketToken);
            case tokens_1.SyntaxKind.LexicalKeyword:
                return this.parseLexicalGoalAssertionTail(openBracketToken);
            case tokens_1.SyntaxKind.TildeToken:
            case tokens_1.SyntaxKind.PlusToken:
                return this.parseParameterValueAssertionTail(openBracketToken);
            default:
                return this.parseInvalidAssertionTail(openBracketToken);
        }
    };
    Parser.prototype.parseTerminal = function (allowOptional) {
        var fullStart = this.scanner.getStartPos();
        var text = this.readTokenValue(tokens_1.SyntaxKind.Terminal);
        var questionToken = allowOptional ? this.parseToken(tokens_1.SyntaxKind.QuestionToken) : undefined;
        var node = new nodes_1.Terminal(text, questionToken);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.isStartOfArgument = function () {
        return this.token === tokens_1.SyntaxKind.QuestionToken
            || this.canBeIdentifier(this.token);
    };
    Parser.prototype.parseArgument = function () {
        var fullStart = this.scanner.getStartPos();
        var questionToken = this.parseToken(tokens_1.SyntaxKind.QuestionToken);
        var name = this.parseIdentifier();
        var node = new nodes_1.Argument(questionToken, name);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseArgumentListTail = function (openToken, parsingContext, closeTokenKind) {
        var elements = this.parseList(parsingContext);
        var closeToken = this.parseToken(closeTokenKind);
        var node = new nodes_1.ArgumentList(openToken, elements, closeToken);
        return this.finishNode(node, openToken.pos);
    };
    Parser.prototype.tryParseArgumentList = function () {
        var openToken = this.parseToken(tokens_1.SyntaxKind.OpenParenToken);
        if (openToken) {
            return this.parseArgumentListTail(openToken, ParsingContext.Arguments, tokens_1.SyntaxKind.CloseParenToken);
        }
        else if (this.isStartOfArgumentList()) {
            openToken = this.parseToken(tokens_1.SyntaxKind.OpenBracketToken);
            return this.parseArgumentListTail(openToken, ParsingContext.BracketedArguments, tokens_1.SyntaxKind.CloseBracketToken);
        }
        return undefined;
    };
    Parser.prototype.isStartOfArgumentList = function () {
        var _this = this;
        if (this.token === tokens_1.SyntaxKind.OpenBracketToken) {
            return this.lookahead(function () { return _this.nextTokenIsArgument(); });
        }
        return false;
    };
    Parser.prototype.nextTokenIsArgument = function () {
        this.nextToken();
        return this.token === tokens_1.SyntaxKind.QuestionToken
            || this.token === tokens_1.SyntaxKind.Identifier;
    };
    Parser.prototype.parseNonterminal = function (allowOptional) {
        var fullStart = this.scanner.getStartPos();
        var name = this.parseIdentifier();
        var argumentList = this.tryParseArgumentList();
        var questionToken = allowOptional ? this.parseToken(tokens_1.SyntaxKind.QuestionToken) : undefined;
        var node = new nodes_1.Nonterminal(name, argumentList, questionToken);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseOneOfSymbol = function () {
        var fullStart = this.scanner.getStartPos();
        var oneKeyword = this.parseToken(tokens_1.SyntaxKind.OneKeyword);
        var ofKeyword = this.parseToken(tokens_1.SyntaxKind.OfKeyword);
        var symbols = this.parseList(ParsingContext.OneOfSymbolList);
        var node = new nodes_1.OneOfSymbol(oneKeyword, ofKeyword, symbols);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parsePlaceholderSymbol = function () {
        var fullStart = this.scanner.getStartPos();
        var node = new nodes_1.LexicalSymbol(this.token);
        this.nextToken();
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseInvalidSymbol = function () {
        var fullStart = this.scanner.getStartPos();
        var node = new nodes_1.LexicalSymbol(tokens_1.SyntaxKind.InvalidSymbol);
        this.skipUntil(isInvalidSymbolRecoveryToken);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseUnicodeCharacterRangeOrHigher = function (allowOptional) {
        var symbol = this.parseUnicodeCharacterLiteral(allowOptional);
        if (!allowOptional) {
            var throughKeyword = this.parseToken(tokens_1.SyntaxKind.ThroughKeyword);
            if (throughKeyword) {
                return this.parseUnicodeCharacterRangeTail(symbol, throughKeyword);
            }
        }
        return symbol;
    };
    Parser.prototype.parseUnicodeCharacterRangeTail = function (left, throughKeyword) {
        var right = this.parseUnicodeCharacterLiteral(/*allowOptional*/ false);
        var node = new nodes_1.UnicodeCharacterRange(left, throughKeyword, right);
        return this.finishNode(node, left.pos);
    };
    Parser.prototype.parsePrimarySymbol = function (allowOptional) {
        switch (this.token) {
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
                return this.parseUnicodeCharacterRangeOrHigher(allowOptional);
            case tokens_1.SyntaxKind.Terminal:
                return this.parseTerminal(allowOptional);
            case tokens_1.SyntaxKind.Identifier:
                return this.parseNonterminal(allowOptional);
            case tokens_1.SyntaxKind.AtToken:
                return this.parsePlaceholderSymbol();
            default:
                return this.parseInvalidSymbol();
        }
    };
    Parser.prototype.parseUnarySymbol = function () {
        switch (this.token) {
            case tokens_1.SyntaxKind.OneKeyword:
                return this.parseOneOfSymbol();
            default:
                return this.parsePrimarySymbol(/*allowOptional*/ true);
        }
    };
    Parser.prototype.tryParseThroughOperator = function () {
        if (this.token === tokens_1.SyntaxKind.ThroughKeyword) {
            return this.parseToken(tokens_1.SyntaxKind.ThroughKeyword);
        }
        return undefined;
    };
    Parser.prototype.parseButNotSymbolTail = function (left, butKeyword, notKeyword) {
        var right = this.parseSymbol();
        var node = new nodes_1.ButNotSymbol(left, butKeyword, notKeyword, right);
        return this.finishNode(node, left.pos);
    };
    Parser.prototype.parseSymbol = function () {
        if (this.token === tokens_1.SyntaxKind.OpenBracketToken) {
            return this.parseAssertion();
        }
        var symbol = this.parseUnarySymbol();
        var butKeyword = this.parseToken(tokens_1.SyntaxKind.ButKeyword);
        var notKeyword = this.parseToken(tokens_1.SyntaxKind.NotKeyword);
        if (butKeyword || notKeyword) {
            return this.parseButNotSymbolTail(symbol, butKeyword, notKeyword);
        }
        return symbol;
    };
    Parser.prototype.tryParseSymbolSpan = function () {
        if (this.isStartOfSymbolSpan()) {
            return this.parseSymbolSpanRest();
        }
        return undefined;
    };
    Parser.prototype.parseSymbolSpanRest = function () {
        var fullStart = this.scanner.getStartPos();
        var symbol = this.parseSymbol();
        var next = this.tryParseSymbolSpan();
        var node = new nodes_1.SymbolSpan(symbol, next);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseSymbolSpan = function () {
        var fullStart = this.scanner.getStartPos();
        if (this.token === tokens_1.SyntaxKind.Prose) {
            var symbol = this.parseProse();
            var node = new nodes_1.SymbolSpan(symbol, /*next*/ undefined);
            return this.finishNode(node, fullStart);
        }
        else {
            return this.parseSymbolSpanRest();
        }
    };
    Parser.prototype.isStartOfSymbolSpan = function () {
        switch (this.token) {
            case tokens_1.SyntaxKind.UnicodeCharacterLiteral:
            case tokens_1.SyntaxKind.Terminal:
            case tokens_1.SyntaxKind.Identifier:
            case tokens_1.SyntaxKind.OpenBracketToken:
            case tokens_1.SyntaxKind.Prose:
            case tokens_1.SyntaxKind.AtToken:
                return true;
            default:
                return false;
        }
    };
    Parser.prototype.isStartOfRightHandSide = function () {
        return this.isStartOfSymbolSpan();
    };
    Parser.prototype.parseLinkReference = function () {
        if (this.token === tokens_1.SyntaxKind.LinkReference) {
            var fullStart = this.scanner.getStartPos();
            var text = this.readTokenValue(tokens_1.SyntaxKind.LinkReference);
            var node = new nodes_1.LinkReference(text);
            return this.finishNode(node, fullStart);
        }
        return undefined;
    };
    Parser.prototype.parseRightHandSide = function () {
        var fullStart = this.scanner.getStartPos();
        var head = this.parseSymbolSpan();
        var reference = this.parseLinkReference();
        var node = new nodes_1.RightHandSide(head, reference);
        if (this.parsingContext !== ParsingContext.RightHandSideListIndented) {
            this.parseOptional(tokens_1.SyntaxKind.LineTerminatorToken);
        }
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseRightHandSideList = function () {
        var fullStart = this.scanner.getStartPos();
        var openIndentToken = this.parseToken(tokens_1.SyntaxKind.IndentToken);
        var elements = openIndentToken && this.parseList(ParsingContext.RightHandSideListIndented) || [];
        var closeIndentToken = this.parseToken(tokens_1.SyntaxKind.DedentToken);
        var node = new nodes_1.RightHandSideList(openIndentToken, elements, closeIndentToken);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseBody = function () {
        if (this.token === tokens_1.SyntaxKind.OneKeyword) {
            return this.parseOneOfList();
        }
        else if (this.token === tokens_1.SyntaxKind.LineTerminatorToken) {
            this.nextToken();
            return this.parseRightHandSideList();
        }
        else {
            return this.parseRightHandSide();
        }
    };
    Parser.prototype.parseProduction = function () {
        var fullStart = this.scanner.getStartPos();
        var name = this.parseIdentifier();
        var parameters = this.tryParseParameterList();
        var colonToken = this.parseAnyToken(isProductionSeparatorToken);
        var body = this.parseBody();
        var node = new nodes_1.Production(name, parameters, colonToken, body);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.parseStringLiteral = function () {
        if (this.token === tokens_1.SyntaxKind.StringLiteral) {
            var fullStart = this.scanner.getStartPos();
            var text = this.scanner.getTokenValue();
            var node = new nodes_1.StringLiteral(text);
            this.nextToken();
            return this.finishNode(node, fullStart);
        }
        return undefined;
    };
    Parser.prototype.parseImport = function () {
        var fullStart = this.scanner.getStartPos();
        var atToken = this.parseToken(tokens_1.SyntaxKind.AtToken);
        var importKeyword = this.parseToken(tokens_1.SyntaxKind.ImportKeyword);
        var path = this.parseStringLiteral();
        var node = new nodes_1.Import(atToken, importKeyword, path);
        return this.finishNode(node, fullStart);
    };
    Parser.prototype.isStartOfSourceElement = function () {
        switch (this.token) {
            case tokens_1.SyntaxKind.AtToken: // Import
            case tokens_1.SyntaxKind.Identifier:
                return true;
            case tokens_1.SyntaxKind.ColonToken:
            case tokens_1.SyntaxKind.ColonColonToken:
            case tokens_1.SyntaxKind.ColonColonColonToken:
            case tokens_1.SyntaxKind.OpenParenToken:
                // Assume we're parsing a production for error recovery purposes
                return true;
            default:
                return false;
        }
    };
    Parser.prototype.parseSourceElement = function () {
        switch (this.token) {
            case tokens_1.SyntaxKind.Identifier:
                return this.parseProduction();
            case tokens_1.SyntaxKind.AtToken:
                return this.parseImport();
            default:
                this.diagnostics.report(this.scanner.getStartPos(), diagnostics_1.Diagnostics.Unexpected_token_0_, tokens_1.tokenToString(this.token));
                return;
        }
    };
    Parser.prototype.parseSourceElementList = function () {
        return this.parseList(ParsingContext.SourceElements);
    };
    return Parser;
})();
exports.Parser = Parser;
function isSourceElementsRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isParametersRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseParenToken
        || token === tokens_1.SyntaxKind.ColonToken
        || token === tokens_1.SyntaxKind.ColonColonToken
        || token === tokens_1.SyntaxKind.ColonColonColonToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isBracketedParametersRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseBracketToken
        || token === tokens_1.SyntaxKind.ColonToken
        || token === tokens_1.SyntaxKind.ColonColonToken
        || token === tokens_1.SyntaxKind.ColonColonColonToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isArgumentsRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseParenToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isBracketedArgumentsRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseBracketToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isRightHandSideListIndentedRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.DedentToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isSymbolSetRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.CommaToken
        || token === tokens_1.SyntaxKind.Terminal
        || token === tokens_1.SyntaxKind.CloseBraceToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isOneOfListRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.Terminal
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isOneOfListIndentedRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.Terminal
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isOneOfSymbolListRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.OrKeyword
        || token === tokens_1.SyntaxKind.Terminal
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.OpenBracketToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isNoSymbolHereRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.OrKeyword
        || token === tokens_1.SyntaxKind.HereKeyword
        || token === tokens_1.SyntaxKind.Terminal
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.CloseBracketToken
        || token === tokens_1.SyntaxKind.QuestionToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isInvalidSymbolRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.OpenBracketToken
        || token === tokens_1.SyntaxKind.Terminal
        || token === tokens_1.SyntaxKind.Identifier
        || token === tokens_1.SyntaxKind.LineTerminatorToken;
}
function isInvalidConstraintTailRecoveryToken(token) {
    return token === tokens_1.SyntaxKind.CloseBracketToken
        || token === tokens_1.SyntaxKind.LineTerminatorToken
        || token === tokens_1.SyntaxKind.Terminal
        || token === tokens_1.SyntaxKind.Identifier;
}
function isProductionSeparatorToken(token) {
    return token === tokens_1.SyntaxKind.ColonToken
        || token === tokens_1.SyntaxKind.ColonColonToken
        || token === tokens_1.SyntaxKind.ColonColonColonToken;
}

//# sourceMappingURL=parser.js.map
